# CDK プロジェクト ファイル構造説明

このドキュメントでは、AWS CDK 学習用プロジェクトの各ファイルが何のために存在し、どのような役割を果たしているのかを、CDK 初心者向けに説明します。

## 📁 プロジェクト全体構造

```
lab-infra/
├── bin/                    # エントリーポイント（アプリケーションの起動点）
│   └── lab-infra.ts      # CDKアプリケーションのメイン設定ファイル
├── lib/                    # スタック定義（実際のAWSリソース定義）
│   ├── network-stack.ts    # ネットワーク関連リソース（VPC、サブネット）
│   ├── fargate-service-stack.ts  # ECS Fargate関連リソース
│   └── pipeline-stack.ts  # CI/CDパイプライン関連リソース
├── documents/              # ドキュメント類
├── package.json           # Node.jsプロジェクト設定とスクリプト定義
├── cdk.json              # CDK設定ファイル
├── tsconfig.json         # TypeScript設定ファイル
├── README.md             # プロジェクト説明書
└── .gitignore           # Git管理対象外ファイルの指定
```

## 🔧 設定ファイル群

### package.json

**役割**: Node.js プロジェクトの設定ファイル
**内容**:

- プロジェクト名、バージョン、説明
- 依存関係（CDK ライブラリなど）
- NPM スクリプト（ビルド、デプロイコマンドなど）

**重要なスクリプト**:

- `npm run build`: TypeScript を JavaScript にコンパイル
- `npm run synth`: CloudFormation テンプレート生成
- `npm run deploy`: 全スタックを AWS にデプロイ
- `npm run destroy`: 全スタックを削除

### cdk.json

**役割**: CDK 固有の設定ファイル
**内容**:

- CDK アプリケーションの起動方法
- ファイル監視設定（開発時の自動リロード）
- CDK の機能フラグ設定（新機能の有効/無効）

**重要な設定**:

- `"app"`: CDK アプリケーションの起動コマンド
- `"context"`: CDK の動作を制御するフラグ群

### tsconfig.json

**役割**: TypeScript 設定ファイル
**内容**:

- TypeScript コンパイラの設定
- 対象 ECMAScript バージョン
- 型チェックの厳密さ

**なぜ TypeScript?**:

- 型安全性によりバグを事前に発見
- IDE での補完機能が充実
- 大規模プロジェクトでの保守性向上

## 🚀 アプリケーション起動ファイル

### bin/lab-infra.ts

**役割**: CDK アプリケーションのエントリーポイント
**重要な処理**:

1. **環境設定**: AWS アカウント ID とリージョンの指定
2. **スタック作成**: 3 つのスタックを順番に作成
3. **依存関係設定**: スタック間の依存関係を定義
4. **タグ付け**: 全リソースに共通タグを設定

**スタック作成順序**:

1. NetworkStack（基盤ネットワーク）
2. FargateServiceStack（アプリケーション）← NetworkStack に依存
3. PipelineStack（CI/CD）← 独立

**初心者向けポイント**:

- このファイルが「設計図の目次」のような役割
- 実際の AWS リソースは`lib/`フォルダで定義
- 依存関係を正しく設定しないとデプロイエラーになる

## 🏗️ スタック定義ファイル群（lib/）

### network-stack.ts

**役割**: ネットワーク基盤の構築
**作成する AWS リソース**:

- **VPC**: プライベートクラウドネットワーク（10.0.0.0/16）
- **パブリックサブネット**: インターネット接続可能（×2、各 AZ）
- **プライベートサブネット**: 内部専用（×2、各 AZ）
- **インターネットゲートウェイ**: インターネット接続用

**SAA 知識との関連**:

- VPC は「仮想的なデータセンター」
- サブネットは「ネットワークの区画」
- マルチ AZ 構成で高可用性を実現

**初心者向けポイント**:

- 他のスタックがこの VPC を参照する
- NAT ゲートウェイは作成しない（コスト削減）
- CIDR ブロックの理解が重要

### fargate-service-stack.ts

**役割**: コンテナアプリケーションの実行環境構築
**作成する AWS リソース**:

- **ECS クラスター**: コンテナ実行の論理グループ
- **タスク定義**: コンテナの設定（CPU、メモリ、イメージ）
- **Fargate サービス**: 継続的なコンテナ実行
- **セキュリティグループ**: ネットワークアクセス制御
- **CloudWatch Logs**: ログ収集・保存
- **IAM ロール**: 権限管理

**SAA 知識との関連**:

- ECS = Elastic Container Service（コンテナオーケストレーション）
- Fargate = サーバーレスコンテナ実行環境
- セキュリティグループ = 仮想ファイアウォール

**初心者向けポイント**:

- EC2 インスタンス管理不要（Fargate の利点）
- タスク定義 = Docker コンテナの設定書
- セキュリティグループでポート 80 を開放

### pipeline-stack.ts

**役割**: CI/CD パイプラインの構築
**作成する AWS リソース**:

- **S3 バケット**: ソースコードとアーティファクト保存
- **CodeBuild**: CDK プロジェクトのビルド
- **CodePipeline**: 自動デプロイワークフロー
- **IAM ロール**: 各サービスの実行権限

**パイプラインの流れ**:

1. **Source**: S3 からソースコード取得
2. **Build**: `cdk synth`で CloudFormation テンプレート生成
3. **Deploy**: CloudFormation でスタックデプロイ

**SAA 知識との関連**:

- CI/CD = 継続的インテグレーション/デプロイメント
- CodePipeline = AWS の CI/CD サービス
- CloudFormation = Infrastructure as Code

**初心者向けポイント**:

- 手動で S3 に ZIP アップロード → 自動デプロイ
- GitHub などの連携は今回なし（学習簡素化）
- 管理者権限使用（本番では最小権限推奨）

## 📋 各ファイルの学習優先度

### 🔴 最重要（必ず理解）

1. **bin/lab-infra.ts**: 全体の構成理解
2. **package.json**: NPM スクリプトの使い方
3. **network-stack.ts**: VPC 基礎概念

### 🟡 重要（段階的に理解）

4. **fargate-service-stack.ts**: ECS/Fargate の理解
5. **cdk.json**: CDK 設定の基本

### 🟢 発展（慣れてから）

6. **pipeline-stack.ts**: CI/CD 概念
7. **tsconfig.json**: TypeScript 設定

## 🎯 学習の進め方

### ステップ 1: 基礎理解

1. `bin/lab-infra.ts`を読んで全体像を把握
2. `package.json`のスクリプトを実行してみる
3. `network-stack.ts`で VPC 概念を学習

### ステップ 2: 実践

1. `cdk synth`でテンプレート生成を体験
2. `cdk deploy`で実際にリソース作成
3. AWS コンソールで作成されたリソースを確認

### ステップ 3: 応用

1. `fargate-service-stack.ts`でコンテナ実行を理解
2. `pipeline-stack.ts`で CI/CD 概念を学習
3. 設定値を変更して動作の違いを確認

## 🔍 よくある疑問と回答

### Q: なぜ TypeScript を使うの？

**A**: 型安全性により、設定ミスを事前に発見できるため。CDK は設定項目が多く、型チェックが重要。

### Q: スタックを分ける理由は？

**A**:

- 責任の分離（ネットワーク、アプリ、CI/CD で役割が異なる）
- 独立したライフサイクル管理
- 再利用性の向上

### Q: なぜ Fargate を選んだの？

**A**:

- サーバー管理不要（学習の焦点をアプリに集中）
- スケーラビリティが高い
- 従量課金でコスト効率が良い

### Q: CI/CD パイプラインは必要？

**A**:

- 手動デプロイのミス防止
- 一貫性のあるデプロイプロセス
- 本格運用では必須の概念

## 📚 次のステップ

1. **Application Load Balancer 追加**: 負荷分散の学習
2. **RDS データベース追加**: データ永続化の学習
3. **Auto Scaling 設定**: 自動スケーリングの学習
4. **監視・アラート設定**: CloudWatch 活用
5. **セキュリティ強化**: IAM 権限の最小化

---

このドキュメントを参考に、各ファイルの役割を理解しながら CDK を学習してください。分からない部分があれば、該当ファイルのコメントも参考にしてください。
